---
title: API and Patterns
description: Comprehensive guide to Suvidha's core APIs and usage patterns
---

# Core API Methods

<AccordionGroup>
<Accordion title=".body(schema: ZodType)" icon="code">

### Purpose
Validate and type the request body using Zod schemas

### Parameters
- `schema`: Zod schema definition
- Returns: Chainable Suvidha instance

### Example
```ts
Suvidha.create()
  .body(z.object({
    email: z.string().email(),
    password: z.string().min(8)
  }))
```

### Behavior
- Validates request body before middleware/handler execution
- Overrides default `any` type with schema inference

</Accordion>

<Accordion title=".params(schema: ZodType)" icon="code">

### Purpose
Validate and type URL path parameters

### Example
```ts
.params(z.object({
  userId: z.string().uuid(),
  postId: z.coerce.number()
}))
```

### Access in Handler
```ts
handler(req => {
  console.log(req.params.userId); // Type-safe string
})
```

</Accordion>

<Accordion title=".query(schema: ZodType)" icon="code">

### Purpose
Validate and type query string parameters

### Example
```ts
.query(z.object({
  page: z.number().default(1),
  sort: z.enum(['asc', 'desc'])
}))
```

### Default Values
```ts
// If ?page=3 not provided
req.query.page // 1 (from default)
```

</Accordion>

<Accordion title=".use(middleware)" icon="code">

### Purpose
Builds request context through chainable middleware. Each call merges new properties into the context while preserving type safety.
Any exceptions thrown will be handled by `onErr` handler.

<AccordionGroup> <Accordion title="Key Characteristics" icon="key">
- **Order-Sensitive**: Middleware executes in declaration order
- **Type Accumulation**: Each middleware's return type merges with previous context
- **Immutable Context**: Each middleware gets current context in `Readonly` wrapper to prevent mutations
- **Early Termination**: Middleware can end response with `conn.res.send()`

</Accordion> </AccordionGroup>

<Note> Merging is same as `...` spread operator, `new_ctx = { ...current_ctx, ...ctx }` </Note>


### Middleware Signature
```ts
type Middleware<Ctx> = (
  conn: Conn<CurrentContext>
) => Ctx | Promise<Ctx>
```

### Example
```ts
.use(async (conn) => ({
  user: await authenticate(conn.req)
}))
.use((conn) => ({
  permissions: getPermissions(conn.context.user)
}))
```

### Type Safety
```ts
// In handler:
req.context.user // AuthenticatedUser
req.context.permissions // string[]
```

</Accordion>

<Accordion title=".handler(fn)" icon="code">

### Purpose
Define final request handler with full type safety.

### Signature
```ts
.handler(
  (req: CtxRequest, res: Response, next: NextFunction) => Reply
)
```

### Parameters
- `req` is express' `Request` object with added context
- `res` is express' `Request` object
- `next` is express' `NextFunction` to call next middleware


### Return Handling
| Return Type       | Behavior                               |
|-------------------|----------------------------------------|
| `undefined`       | Must call `res.send()` manually to send the response |
| `Http.End` \| `Other Values` | Processed by `onComplete` handler (If headers not sent) |

</Accordion>
</AccordionGroup>

# Advanced Patterns

## Type-Safe Context Building

Build context through ordered middlewares - TypeScript enforces dependency sequence:

```ts
app.get(
    "/reports",
    suvidha()
        .use(() => ({ auth: getAuth() })) // { auth: Auth }
        .use((conn) => ({
            // Requires previous auth
            user: getUser(conn.context.auth), // + { user: User }
        }))
        .use(async (conn) => ({
            // Requires user
            report: await fetchReport(conn.context.user), // + { report: Report }
        }))
        .handler((req) => req.context.report), // Final: auth + user + report
);
```
Reorder middlewares → Type error ← Context dependencies broken.

## Custom Validation Handlers

```ts Override onSchemaErr
class CustomHandlers extends DefaultHandlers {
  onSchemaErr(err: ZodError, conn: Conn) {
    conn.res.status(422).json({
      type: "VALIDATION_FAILURE",
      details: err.issues.map(issue => ({
        field: issue.path.join('.'),
        message: issue.message
      }))
    });
  }
}

// Usage
Suvidha.create(new CustomHandlers())
  .body(userSchema)
  // ...
```

# Migration Guide

## From Express Middleware

<CodeGroup>

```ts Before
app.post('/login', 
  (req, res, next) => {
    if (!validateBody(req.body)) {
      return res.status(400).json({ error: "Invalid" });
    }
    next();
  },
  (req, res) => {
    // Handler logic
  }
);
```

```ts After
app.post('/login',
  Suvidha.create()
    .body(loginSchema)
    .handler(req => {
      return handleLogin(req.body);
    })
);
```
</CodeGroup>
